#-*- coding: utf-8 -*-

## @author Ilyas Kuhlemann
# @author Francesca Sch√∂nsberg
# @author Diemut Regel
# @author Burooj Ghani
#
# @contact ilyasp.ku@gmail.com
#
# @date 28.03.2015

"""
This file holds a class designed to analyze phases- and spikes-files created with system.WithOutput. 
"""

import numpy as np
import sys

## Defines the memory cap, if an array exceeds it, no other array will be loaded from file.
ARRAY_MEMORY=1.6*10**9 # in byte

class Analyzer:
    """
    A class to handle analysis of phases and spikes as generated by system.WithOutput objects.
    """
    def __init__(self,folder):
        """
        Constructor.
        @param folder Folder (string) that holds the phases*.npy and spikes*.npy files to be analyzed.
        """
    
        self.folder=folder
    
        self.read_parameters()

    def read_parameters(self):
        """
        Loads parameters from 'parameters.pickle' file in self.folder.

        Parameters are being stored in self.parameters.
        """
        import pickle

        with open(self.folder+'/parameters.pickle','rb') as f:
            ## holds the parameters of the simulation that is to be analyzed (reads them from )
            self.parameters=pickle.load(f)
            
        
    def read_spikes(self,indices=None):
        """
        Reads spikes from spikes*.npy in self.folder.
        @param indices If not None, it needs to be an array of indices of neurons of which the spikes are to be read; if None, spikes for all neurons will be read.
        """
        import glob

        f_list=glob.glob(self.folder+'/spikes*.npy')
        f_list.sort()

        ## array that holds spikes (of all neurons or all neurons specified in self.read_spikes)
        self.spike_array=None
        memory_use=0

        for i in range(0,len(f_list)):
            if memory_use<ARRAY_MEMORY:
                current_array=np.load(f_list[i])
                if indices==None:
                    pass
                else:
                    current_array=current_array[:,[0]+list(indices)]
                

                if self.spike_array==None:
                    self.spike_array=current_array
                else:
                    if not current_array.shape[0]==0:
                        handle=self.spike_array
                        #print handle.shape
                        #print current_array.shape
                        self.spike_array=np.concatenate((handle,current_array))
                        del handle

                memory_use=self.spike_array.shape[0]*self.spike_array.shape[1]*8
            else:
                print 'WARNING: to much memory in use already'
                break

        if indices==None:
            self.spike_indices=np.arange(0,self.spike_array.shape[1]+1)
        else:
            ## If spikes were not read for all neurons, this variable stores for which neurons the spikes were read
            self.spike_indices=np.array(indices)


    def read_phases(self,start_step=None,end_step=None,indices=None):
        """
        Reads phases from phases*.npy in self.folder.
        @param start_step NOT IMPLEMENTED YET; the user should be able to define a time step from where to start (for memory reasons).
        @param end_step NOT IMPLEMENTED YET; the user should be able to define a time step at which to end (for memory reasons).
        @param indices If not None, it needs to be an array of indices of neurons of which the phases are to be read; if None, phases for all neurons will be read.
        """

        import glob
        f_list=glob.glob(self.folder+'/phases*.npy')
        f_list.sort()

        self.phase_array=None
        memory_use=0

        if start_step==None and end_step==None:
            for i in range(0,len(f_list)):
                current_array=np.load(f_list[i])

                if indices==None:
                    pass
                else:
                    current_array=current_array[:,[0]+list(indices)]
                    
                if self.phase_array==None:
                    self.phase_array=current_array
                        
                else:
                    if memory_use<ARRAY_MEMORY:
                        handle=self.phase_array
                        self.phase_array=np.concatenate((handle,current_array))
                        del handle
                    else:
                        print 'ERROR in read_phases: too much memory used.'
                        sys.exit(1)
                
    

                memory_use=self.phase_array.shape[0]*self.phase_array.shape[1]*8 # in byte for float64

        if indices==None:
            self.phases_indices=np.arange(1,self.phase_array.shape[1]+1)
        else:
            self.phases_indices=np.array(indices)


    def compute_CV(self):
        """
        Computes the coefficient of variation (CV) of the inter-spike intervals (ISI) for each neuron.
        
        The CV is defined as standard deviation std devided by mean m, std/m.
        @return 1-d array containing one CV value per neuron; if the value is -1, this means that there were not enough spikes (or ISIs) to compute the CV.
        """
        vCV=[]


        n_no_two_spikes=0
        n_enough_spikes=0

        for i in range(1, self.spike_array.shape[1]):

            ind_vec=np.where(self.spike_array[:,i])[0] #this vector gives all the rows of spikes matrix, that contain a spike of neuron i
            vISI=np.array(self.spike_array[ind_vec[1:],0]-self.spike_array[ind_vec[:-1],0]) #this is the vector that contains all ISIs for neuron i
            
            if vISI.shape[0]>0:
                n_enough_spikes+=1
                m=vISI.mean()
                std=vISI.std()
                if m==0:
                    CV=0
                    
                else:
                    CV=std/m
                    


                vCV.append(CV)
                

            else:
                n_no_two_spikes+=1
                vCV.append(-1)

        
        if n_no_two_spikes>0:
            f=open('CV_log.txt','w')
            log_s=''

            log_s+='WARNING: not all neurons spiked often enough to compute CV\n'

            log_s+='Of '+str(self.spike_array.shape[1]-1)+' neurons, for '+str(n_no_two_spikes)+' those values could not be computed.\n'
            log_s+='Of '+str(self.spike_array.shape[1]-1)+' neurons, for '+str(n_enough_spikes)+' those values were be computed.\n'

            print log_s
            

            f.write(log_s)
            f.close()
        

        return np.array(vCV)

    def compute_rates(self,dt,shape='triangle',kw_params={'width':1.0,'height':1.0}):
        """
        Compute the rates for each population with a sliding window of specified shape.

        At the moment only the option 'triangle' is implemented for the shape parameter.
        @param dt Time step of the sliding window in periods T of the oscillators (neurons).
        @param shape Keyword (string) defining the shape of the sliding window; only 'triangle' implemented by now.
        @param kw_params Dictionary that holds parameters for the sliding window; for triangle it needs to specify 'width' and 'height'.
        @return Array holding center of sliding window (time in terms of periods T) in first row, rates for each population in following row, total rates for all internal neurons of the simulated system in last row.
        """
        spikes_sums=[]
        for i in range(0,self.parameters['N'].shape[0]): # for number of populations
            sums=np.sum(self.spike_array[:,self.parameters['N'][:i].sum()+1:self.parameters['N'][:i+1].sum()+1],axis=1)
            # sums = array of summed-up number of spikes for population i at each event (that is, point in time) 
            spikes_sums.append(sums)
        
        spikes_sums.append(np.sum(self.spike_array[:,1:self.parameters['N'].sum()+1],axis=1))


        t=np.arange(0,self.spike_array[:,0][-1],dt)
        rates=np.zeros((t.shape[0],len(self.parameters['N'])+2))

        rates[:,0]=t
        if shape=='triangle':
            f=lambda(delta_t): kw_params['height']*(1-np.abs(delta_t)/kw_params['width'])
            A=kw_params['width']*kw_params['height']
            
            i=0
            for t_i in t:
                in_range=np.where((self.spike_array[:,0]<=t_i+kw_params['width']) & (self.spike_array[:,0]>=t_i-kw_params['width']))[0]
                
                delta_t=self.spike_array[:,0][in_range]-t_i # difference between each time stamp 'in range' and the current center of the time triangle t_i

                for j in range(1,rates.shape[1]-1):
                    tri=f(delta_t)
                    #print tri.shape
                    rates[i,j]=((tri*spikes_sums[j-1][in_range]).sum())/A/self.parameters['N'][j-1]
                #rates[i,j+1]= --> for all populations
                rates[i,j+1]=((tri*spikes_sums[j][in_range]).sum())/A/self.parameters['N'].sum()
                i+=1
                
        return rates

        
    def plot_rates(self,ax,rates,plot_args=[],plot_kwargs={}):
        """
        Plots given rates.
        """
        if plot_kwargs.keys().count('label'):
            generate_labels=False
        else:
            generate_labels=True

        for i in range(1,rates.shape[1]):
            
            if generate_labels:
                if i<=len(self.parameters['N']):
                    plot_kwargs['label']='pop '+str(i)
                else:
                    plot_kwargs['label']='total'
            ax.plot(rates[:,0],rates[:,i],*plot_args,**plot_kwargs)
        ax.set_xlabel('$t\;[T]$')
        ax.set_ylabel('normalized rates')
        ax.legend()
        
    def plot_CV(self,ax,CV_data,bins=20,hist_args=[],hist_kwargs={}):
        ax.hist(CV_data,bins=bins,*hist_args,**hist_kwargs)   
        ax.set_xlabel(r'$CV\; ISI_i$')  
        ax.set_ylabel(r'$ N_{neurons}$')
        ax.set_title('Coefficient of variation')

    def plot_single_spike_train(self,ax,t_indices,size,offset,plot_args=[],plot_kwargs={}):
        return ax.vlines(self.spike_array[:,0][t_indices],offset,offset+size,*plot_args,**plot_kwargs)
        
    def plot_spike_trains(self,ax,indices,size=1,distance=0.0,plot_args=[],plot_kwargs={}):
        lines=[]
        offset=0

        print indices


        for i in indices:
            index=np.where(self.spike_indices==i)[0]+1
            t_indices=np.where(self.spike_array[:,index]==1)[0]
            lines.append(self.plot_single_spike_train(ax,t_indices,size,offset,plot_args,plot_kwargs))
            offset=offset+size+distance
        return lines
        

    def plot_single_phase_dynamics(self,ax,n,plot_args=[],plot_kwargs={}):
        if plot_kwargs.keys().count('label'):
            pass
        else:
            plot_kwargs['label']='n'+str(n)
        ax.plot(self.phase_array[:,0],self.phase_array[:,np.where(self.phases_indices==n)[0]+1],*plot_args,**plot_kwargs)
        
        
